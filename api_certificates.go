/*
Nginx Proxy Manager API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.12.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package nginxproxymanager

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// CertificatesAPIService CertificatesAPI service
type CertificatesAPIService service

type ApiCreateCertificateRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	createCertificateRequest *CreateCertificateRequest
}

// Certificate Payload
func (r ApiCreateCertificateRequest) CreateCertificateRequest(createCertificateRequest CreateCertificateRequest) ApiCreateCertificateRequest {
	r.createCertificateRequest = &createCertificateRequest
	return r
}

func (r ApiCreateCertificateRequest) Execute() (*GetCertificates200ResponseInner, *http.Response, error) {
	return r.ApiService.CreateCertificateExecute(r)
}

/*
CreateCertificate Create a Certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCertificateRequest
*/
func (a *CertificatesAPIService) CreateCertificate(ctx context.Context) ApiCreateCertificateRequest {
	return ApiCreateCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCertificates200ResponseInner
func (a *CertificatesAPIService) CreateCertificateExecute(r ApiCreateCertificateRequest) (*GetCertificates200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCertificates200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.CreateCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCertificateRequest == nil {
		return localVarReturnValue, nil, reportError("createCertificateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCertificateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateCertificate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCertificateRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	certID int64
}

func (r ApiDeleteCertificateRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.DeleteCertificateExecute(r)
}

/*
DeleteCertificate Delete a Certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certID
 @return ApiDeleteCertificateRequest
*/
func (a *CertificatesAPIService) DeleteCertificate(ctx context.Context, certID int64) ApiDeleteCertificateRequest {
	return ApiDeleteCertificateRequest{
		ApiService: a,
		ctx: ctx,
		certID: certID,
	}
}

// Execute executes the request
//  @return bool
func (a *CertificatesAPIService) DeleteCertificateExecute(r ApiDeleteCertificateRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.DeleteCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates/{certID}"
	localVarPath = strings.Replace(localVarPath, "{"+"certID"+"}", url.PathEscape(parameterValueToString(r.certID, "certID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certID < 1 {
		return localVarReturnValue, nil, reportError("certID must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadCertificateRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	certID int64
}

func (r ApiDownloadCertificateRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadCertificateExecute(r)
}

/*
DownloadCertificate Downloads a Certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certID
 @return ApiDownloadCertificateRequest
*/
func (a *CertificatesAPIService) DownloadCertificate(ctx context.Context, certID int64) ApiDownloadCertificateRequest {
	return ApiDownloadCertificateRequest{
		ApiService: a,
		ctx: ctx,
		certID: certID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *CertificatesAPIService) DownloadCertificateExecute(r ApiDownloadCertificateRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.DownloadCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates/{certID}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"certID"+"}", url.PathEscape(parameterValueToString(r.certID, "certID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certID < 1 {
		return localVarReturnValue, nil, reportError("certID must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCertificateRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	certID int64
	expand *string
}

// Expansions
func (r ApiGetCertificateRequest) Expand(expand string) ApiGetCertificateRequest {
	r.expand = &expand
	return r
}

func (r ApiGetCertificateRequest) Execute() (*GetCertificates200ResponseInner, *http.Response, error) {
	return r.ApiService.GetCertificateExecute(r)
}

/*
GetCertificate Get a Certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certID
 @return ApiGetCertificateRequest
*/
func (a *CertificatesAPIService) GetCertificate(ctx context.Context, certID int64) ApiGetCertificateRequest {
	return ApiGetCertificateRequest{
		ApiService: a,
		ctx: ctx,
		certID: certID,
	}
}

// Execute executes the request
//  @return GetCertificates200ResponseInner
func (a *CertificatesAPIService) GetCertificateExecute(r ApiGetCertificateRequest) (*GetCertificates200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCertificates200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.GetCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates/{certID}"
	localVarPath = strings.Replace(localVarPath, "{"+"certID"+"}", url.PathEscape(parameterValueToString(r.certID, "certID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certID < 1 {
		return localVarReturnValue, nil, reportError("certID must be greater than 1")
	}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCertificatesRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	expand *string
}

// Expansions
func (r ApiGetCertificatesRequest) Expand(expand string) ApiGetCertificatesRequest {
	r.expand = &expand
	return r
}

func (r ApiGetCertificatesRequest) Execute() ([]GetCertificates200ResponseInner, *http.Response, error) {
	return r.ApiService.GetCertificatesExecute(r)
}

/*
GetCertificates Get all certificates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCertificatesRequest
*/
func (a *CertificatesAPIService) GetCertificates(ctx context.Context) ApiGetCertificatesRequest {
	return ApiGetCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCertificates200ResponseInner
func (a *CertificatesAPIService) GetCertificatesExecute(r ApiGetCertificatesRequest) ([]GetCertificates200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCertificates200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.GetCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRenewCertificateRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	certID int64
}

func (r ApiRenewCertificateRequest) Execute() (*GetCertificates200ResponseInner, *http.Response, error) {
	return r.ApiService.RenewCertificateExecute(r)
}

/*
RenewCertificate Renews a Certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certID
 @return ApiRenewCertificateRequest
*/
func (a *CertificatesAPIService) RenewCertificate(ctx context.Context, certID int64) ApiRenewCertificateRequest {
	return ApiRenewCertificateRequest{
		ApiService: a,
		ctx: ctx,
		certID: certID,
	}
}

// Execute executes the request
//  @return GetCertificates200ResponseInner
func (a *CertificatesAPIService) RenewCertificateExecute(r ApiRenewCertificateRequest) (*GetCertificates200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCertificates200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.RenewCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates/{certID}/renew"
	localVarPath = strings.Replace(localVarPath, "{"+"certID"+"}", url.PathEscape(parameterValueToString(r.certID, "certID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certID < 1 {
		return localVarReturnValue, nil, reportError("certID must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestHttpReachRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	domains *string
}

// Expansions
func (r ApiTestHttpReachRequest) Domains(domains string) ApiTestHttpReachRequest {
	r.domains = &domains
	return r
}

func (r ApiTestHttpReachRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestHttpReachExecute(r)
}

/*
TestHttpReach Test HTTP Reachability

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestHttpReachRequest
*/
func (a *CertificatesAPIService) TestHttpReach(ctx context.Context) ApiTestHttpReachRequest {
	return ApiTestHttpReachRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CertificatesAPIService) TestHttpReachExecute(r ApiTestHttpReachRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.TestHttpReach")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates/test-http"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.domains == nil {
		return nil, reportError("domains is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "domains", r.domains, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadCertificateRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	certID int64
	certificate *os.File
	certificateKey *os.File
	intermediateCertificate *os.File
}

func (r ApiUploadCertificateRequest) Certificate(certificate *os.File) ApiUploadCertificateRequest {
	r.certificate = certificate
	return r
}

func (r ApiUploadCertificateRequest) CertificateKey(certificateKey *os.File) ApiUploadCertificateRequest {
	r.certificateKey = certificateKey
	return r
}

func (r ApiUploadCertificateRequest) IntermediateCertificate(intermediateCertificate *os.File) ApiUploadCertificateRequest {
	r.intermediateCertificate = intermediateCertificate
	return r
}

func (r ApiUploadCertificateRequest) Execute() (*UploadCertificate200Response, *http.Response, error) {
	return r.ApiService.UploadCertificateExecute(r)
}

/*
UploadCertificate Uploads a custom Certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certID
 @return ApiUploadCertificateRequest
*/
func (a *CertificatesAPIService) UploadCertificate(ctx context.Context, certID int64) ApiUploadCertificateRequest {
	return ApiUploadCertificateRequest{
		ApiService: a,
		ctx: ctx,
		certID: certID,
	}
}

// Execute executes the request
//  @return UploadCertificate200Response
func (a *CertificatesAPIService) UploadCertificateExecute(r ApiUploadCertificateRequest) (*UploadCertificate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadCertificate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.UploadCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates/{certID}/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"certID"+"}", url.PathEscape(parameterValueToString(r.certID, "certID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certID < 1 {
		return localVarReturnValue, nil, reportError("certID must be greater than 1")
	}
	if r.certificate == nil {
		return localVarReturnValue, nil, reportError("certificate is required and must be specified")
	}
	if r.certificateKey == nil {
		return localVarReturnValue, nil, reportError("certificateKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var certificateLocalVarFormFileName string
	var certificateLocalVarFileName     string
	var certificateLocalVarFileBytes    []byte

	certificateLocalVarFormFileName = "certificate"
	certificateLocalVarFile := r.certificate

	if certificateLocalVarFile != nil {
		fbs, _ := io.ReadAll(certificateLocalVarFile)

		certificateLocalVarFileBytes = fbs
		certificateLocalVarFileName = certificateLocalVarFile.Name()
		certificateLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: certificateLocalVarFileBytes, fileName: certificateLocalVarFileName, formFileName: certificateLocalVarFormFileName})
	}
	var certificateKeyLocalVarFormFileName string
	var certificateKeyLocalVarFileName     string
	var certificateKeyLocalVarFileBytes    []byte

	certificateKeyLocalVarFormFileName = "certificate_key"
	certificateKeyLocalVarFile := r.certificateKey

	if certificateKeyLocalVarFile != nil {
		fbs, _ := io.ReadAll(certificateKeyLocalVarFile)

		certificateKeyLocalVarFileBytes = fbs
		certificateKeyLocalVarFileName = certificateKeyLocalVarFile.Name()
		certificateKeyLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: certificateKeyLocalVarFileBytes, fileName: certificateKeyLocalVarFileName, formFileName: certificateKeyLocalVarFormFileName})
	}
	var intermediateCertificateLocalVarFormFileName string
	var intermediateCertificateLocalVarFileName     string
	var intermediateCertificateLocalVarFileBytes    []byte

	intermediateCertificateLocalVarFormFileName = "intermediate_certificate"
	intermediateCertificateLocalVarFile := r.intermediateCertificate

	if intermediateCertificateLocalVarFile != nil {
		fbs, _ := io.ReadAll(intermediateCertificateLocalVarFile)

		intermediateCertificateLocalVarFileBytes = fbs
		intermediateCertificateLocalVarFileName = intermediateCertificateLocalVarFile.Name()
		intermediateCertificateLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: intermediateCertificateLocalVarFileBytes, fileName: intermediateCertificateLocalVarFileName, formFileName: intermediateCertificateLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateCertificatesRequest struct {
	ctx context.Context
	ApiService *CertificatesAPIService
	certificate *os.File
	certificateKey *os.File
	intermediateCertificate *os.File
}

func (r ApiValidateCertificatesRequest) Certificate(certificate *os.File) ApiValidateCertificatesRequest {
	r.certificate = certificate
	return r
}

func (r ApiValidateCertificatesRequest) CertificateKey(certificateKey *os.File) ApiValidateCertificatesRequest {
	r.certificateKey = certificateKey
	return r
}

func (r ApiValidateCertificatesRequest) IntermediateCertificate(intermediateCertificate *os.File) ApiValidateCertificatesRequest {
	r.intermediateCertificate = intermediateCertificate
	return r
}

func (r ApiValidateCertificatesRequest) Execute() (*ValidateCertificates200Response, *http.Response, error) {
	return r.ApiService.ValidateCertificatesExecute(r)
}

/*
ValidateCertificates Validates given Custom Certificates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateCertificatesRequest
*/
func (a *CertificatesAPIService) ValidateCertificates(ctx context.Context) ApiValidateCertificatesRequest {
	return ApiValidateCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidateCertificates200Response
func (a *CertificatesAPIService) ValidateCertificatesExecute(r ApiValidateCertificatesRequest) (*ValidateCertificates200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateCertificates200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesAPIService.ValidateCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nginx/certificates/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certificate == nil {
		return localVarReturnValue, nil, reportError("certificate is required and must be specified")
	}
	if r.certificateKey == nil {
		return localVarReturnValue, nil, reportError("certificateKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var certificateLocalVarFormFileName string
	var certificateLocalVarFileName     string
	var certificateLocalVarFileBytes    []byte

	certificateLocalVarFormFileName = "certificate"
	certificateLocalVarFile := r.certificate

	if certificateLocalVarFile != nil {
		fbs, _ := io.ReadAll(certificateLocalVarFile)

		certificateLocalVarFileBytes = fbs
		certificateLocalVarFileName = certificateLocalVarFile.Name()
		certificateLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: certificateLocalVarFileBytes, fileName: certificateLocalVarFileName, formFileName: certificateLocalVarFormFileName})
	}
	var certificateKeyLocalVarFormFileName string
	var certificateKeyLocalVarFileName     string
	var certificateKeyLocalVarFileBytes    []byte

	certificateKeyLocalVarFormFileName = "certificate_key"
	certificateKeyLocalVarFile := r.certificateKey

	if certificateKeyLocalVarFile != nil {
		fbs, _ := io.ReadAll(certificateKeyLocalVarFile)

		certificateKeyLocalVarFileBytes = fbs
		certificateKeyLocalVarFileName = certificateKeyLocalVarFile.Name()
		certificateKeyLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: certificateKeyLocalVarFileBytes, fileName: certificateKeyLocalVarFileName, formFileName: certificateKeyLocalVarFormFileName})
	}
	var intermediateCertificateLocalVarFormFileName string
	var intermediateCertificateLocalVarFileName     string
	var intermediateCertificateLocalVarFileBytes    []byte

	intermediateCertificateLocalVarFormFileName = "intermediate_certificate"
	intermediateCertificateLocalVarFile := r.intermediateCertificate

	if intermediateCertificateLocalVarFile != nil {
		fbs, _ := io.ReadAll(intermediateCertificateLocalVarFile)

		intermediateCertificateLocalVarFileBytes = fbs
		intermediateCertificateLocalVarFileName = intermediateCertificateLocalVarFile.Name()
		intermediateCertificateLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: intermediateCertificateLocalVarFileBytes, fileName: intermediateCertificateLocalVarFileName, formFileName: intermediateCertificateLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateCertificate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
